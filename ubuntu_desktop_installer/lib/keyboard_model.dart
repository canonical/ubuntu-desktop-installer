import 'dart:convert';
import 'dart:ui';

import 'package:diacritic/diacritic.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart' show rootBundle;
import 'package:tuple/tuple.dart';

/// A model inheriting ChangeNotifier that reads a file generated by
/// /usr/share/console-setup/kbdnames-maker from the keyboard-configuration
/// package and exposes a localized list of keyboard layouts and variants.
class KeyboardModel extends ChangeNotifier {
  static const _assetName = 'assets/kbdnames.txt';

  final Set<String> _langs = {};

  /// A sorted list of 2-tuples representing the available keyboard layouts
  /// the current locale. Each entry contains a keyboard layout code and the
  /// corresponding localized name of the layout, e.g.:
  ///   - ('kz', 'Kazakh')
  ///   - ('iq', 'Iraqi')
  final List<Tuple2<String, String>> layouts = [];

  /// A map that associates keyboard layout codes with a sorted list of 2-tuples
  /// representing available variants. Each entry in the variant list for a
  /// given layout contains a variant code and the corresponding localized name
  /// of the variant, e.g.:
  ///   - be:
  ///     - ('sundeadkeys', 'Belgian - Belgian (Sun dead keys)')
  ///     - ('oss', 'Belgian - Belgian (alternative)')
  final Map<String, List<Tuple2<String, String>>> variants = {};

  /// Reload the list of layouts and the map of variants for a given locale.
  Future<void> load(Locale locale) async {
    final langtag = locale.toLanguageTag().replaceAll('-', '_');
    final firstpass = _langs.isEmpty;
    var matchinglang = 'C';
    layouts.clear();
    variants.clear();
    // Copied from subiquity's KeyboardList class
    return rootBundle.loadStructuredData(_assetName, (data) async {
      return LineSplitter.split(data);
    }).then((lines) {
      if (firstpass) {
        for (final line in lines) {
          _langs.add(line.split('*')[0]);
        }
      }
      if (_langs.contains(langtag)) {
        matchinglang = langtag;
      } else {
        final langonlytag = langtag.split('_')[0];
        if (_langs.contains(langonlytag)) {
          matchinglang = langonlytag;
        }
      }
      return lines;
    }).then((lines) {
      for (final line in lines) {
        final tokens = line.split('*');
        if (tokens[0] == matchinglang) {
          var element = tokens[1];
          var name = tokens[2];
          if (element == 'layout') {
            layouts.add(Tuple2(name, tokens[3]));
          } else if (element == 'variant') {
            final value = Tuple2<String, String>(tokens[3], tokens[4]);
            if (variants.containsKey(name)) {
              variants[name].add(value);
            } else {
              variants[name] = [value];
            }
          }
        }
      }
      layouts.sort((a, b) =>
          removeDiacritics(a.item2).compareTo(removeDiacritics(b.item2)));
      for (final entry in variants.entries) {
        entry.value.sort((a, b) =>
            removeDiacritics(a.item2).compareTo(removeDiacritics(b.item2)));
      }
      notifyListeners();
    });
  }
}
